Even if that is clear that the methods of an interface are public, we need to mentionate when we override this method that we speak about an public method 

interface blabla {
	double eval();
}

public class alo implements blabla {
	@Override public double eval() {
	}
}





On peut lever/lancer les exceptions avec:
	- throw uneException;

Try / Catch 
	- Dans la section try on et le fonctionnement normal du programme
	- catch : fonctionnement exceptionnel en cas d'erreur
	System.err.println(arg + " n'est pas un nobmre! ");

Une methode peut decider:
	- Attraper les eceptions lancees et les traiter
	- De propager les exceptions 
		1) Il faut le declarer dans la signature de la methode selon la nature
		2) Ex: FileReader(String pathname) throws FileNotFoundException 

Quelques RuntimeException:
	1) NullPointerException
	2) ArrayIndexOutOfBoundsExceptions
	3) NumberFormatException
	4) ClassCastException


    void n() throws IOException
    {
        m();
    }
    void p()
    {
        try {
  
            // exception handled
            n();
        }
        catch (Exception e) {
            System.out.println("exception handled");
        }
    }
  
    public static void main(String args[])
    {
        Simple obj = new Simple();
        obj.p();
        System.out.println("normal flow...");
    }



Definir ses propres exceptions:

Exception non-controle (Unchecked exception)



class CompteBancaire {
	int solde = 0;
	void debiter (int somme) {
		if (somme > solde) throw new DecouvertException(this);
		solde -= somme;
	}
}


class DecouvertException extends RuntimeException {
	CompteBancaire compte;
	DecouvertException (CompteBancaire c) {
		super ("Decouvert non autorise sur " + c);
		this.compte = c;
	}
}


Exception controle (Checked exception)


class CompteBancaire {
	int solde = 0;
	void debiter (int somme) throws DecouvertException {
		if (somme > solde) throw new DecouvertException(this);
		solde -= somme; 
	}
}


class DecouvertException extends Exception { // marche comme une classe, donc on a besoin d'un constructeur 
	CompteBancaire compte; // compte est une variable de type CompteBancaire (qui est une classe)
	DecouvertException (CompteBancaire c){
		super("Decouvert non autorise sur " + c);
		this.compte = c;
	}
}


A compile-time error generally refers to the errors that correspond to the semantics or 
syntax. A runtime error refers to the error that we encounter during the code execution 
during runtime. We can easily fix a compile-time error during the development of code. 
A compiler cannot identify a runtime error.


Java provides the facility to create our own exceptions which are basically derived classes of Exception.
We call the constructor of our mother class (Exception) by using the keyword super(s) - s is the string that will pe printed by the constructor of Exception


Checked Exceptions :
	
	If some code within a method throws a checked exception, then the method must either handle the exception
	or it must specify the exception using the throws keyword. 
	
	"To fix the above program, we either need to specify a list of eceptions using throws,
	 or we need to use a try-catch block. 


Unchecked Exceptions :
	In java, exceptions under Error and RuntimeException classes are unchecked, everything else under throwable is checked


Les blocs try et catch sont des blocs d'instructions 
	- Les variables declarees dans ces blocs meurent a la fin du bloc 










